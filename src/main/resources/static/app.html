<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KLine App</title>
  <link rel="stylesheet" href="/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="/js/param-validation.js"></script>
  <script src="/js/multi-timeframe.js"></script>
  <script src="/js/chart-visualization.js"></script>
  <script src="/js/strategy-management.js"></script>
  <script src="/js/reliability.js"></script>
  <style>
    #chart{height:520px;border:1px solid var(--border);border-radius:8px}
    .panel{display:grid;grid-template-columns:2fr 1fr;gap:16px}
    .kv{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .kv input{width:100px;background:#0b0f13;border:1px solid var(--border);border-radius:6px;color:var(--text);padding:6px}
    .skeleton{height:12px;background:linear-gradient(90deg,#0b0f13,#10151b,#0b0f13);border-radius:4px;animation:sh 1.2s infinite}
    @keyframes sh{0%{background-position:-200px 0}100%{background-position:200px 0}}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="brand"><div class="dot"></div><h1>KLine Analytics</h1></div>
      <div class="toolbar">
        <a class="btn" href="/upload.html">Upload</a>
        <a class="btn" href="/baseline.html">Baseline</a>
        <a class="btn" href="/swagger-ui/index.html">API</a>
      </div>
    </div>

    <div class="panel">
      <div class="card">
        <h3>Chart · Multi-timeframe</h3>
        <div class="content">
          <div class="kv" style="justify-content:space-between">
            <div class="kv">
              <input id="symbol" placeholder="SYMBOL e.g. TEST" />
              <select id="interval"><option value="1d">1d</option><option value="1h">1h</option><option value="4h">4h</option><option value="15m">15m</option></select>
              <button class="primary" id="load">Load</button>
            </div>
            <div class="kv">
              <input id="emaShort" placeholder="emaShort 20" />
              <input id="emaLong" placeholder="emaLong 50" />
              <input id="macdFast" placeholder="macdFast 12" />
              <input id="macdSlow" placeholder="macdSlow 26" />
              <input id="macdSignal" placeholder="macdSignal 9" />
              <button class="btn" id="apply">Apply</button>
              <input type="file" id="overlayImg" accept="image/*" />
              <button class="btn" id="overlayBtn">Overlay</button>
              <label style="color:var(--muted)"><input id="overlayToggle" type="checkbox" checked /> overlay on</label>
              <label style="color:var(--muted)"><input id="linkTf" type="checkbox" checked /> link timeframes</label>
            </div>
          </div>
          <div class="grid2">
            <div>
              <div id="chart" class="chart"></div>
              <div class="legend" style="margin-top:8px">
                <label class="badge"><input type="checkbox" id="toggleSignals" checked /> signals</label>
                <span class="badge"><span class="k k-buy"></span> BUY</span>
                <span class="badge"><span class="k k-sell"></span> SELL</span>
                <span class="badge">overlay: reconstructed candles</span>
              </div>
            </div>
            <div>
              <div class="kv" style="margin-bottom:6px">
                <select id="interval2"><option value="1h">1h</option><option value="15m">15m</option><option value="4h">4h</option><option value="1d">1d</option></select>
                <button class="btn" id="load2">Load</button>
              </div>
              <div id="chart2" class="chart"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="card">
        <h3>Backtest</h3>
        <div class="content">
          <div class="kv"><button class="primary" id="runbt">Run Backtest</button></div>
          <div id="btout" class="mono" style="margin-top:8px;max-height:420px;overflow:auto"></div>
        </div>
      </div>
    </div>

    <div class="card" style="margin-top:16px">
      <h3>Strategies</h3>
      <div class="content" id="strats">
        <div class="skeleton" style="width:100%"></div>
        <div class="kv" style="margin-top:8px">
          <input id="strategyId" placeholder="id (e.g. my-strategy)" />
          <input id="strategyVersion" placeholder="version (e.g. v2)" />
          <textarea id="strategyJson" class="mono" style="width:100%;height:120px" placeholder='{"name":"ema-macd","params":{...}}'></textarea>
        </div>
        <div class="kv" style="margin-top:6px">
          <button class="btn" id="btnPreviewStrategy">Preview</button>
          <button class="primary" id="btnRegisterStrategy">Register</button>
          <button class="btn" id="btnRollbackStrategy" title="Re-register previous version as new version">Rollback</button>
          <span id="stratMsg" class="explain"></span>
        </div>
        <div id="stratList" class="mono" style="margin-top:8px;max-height:200px;overflow:auto"></div>
      </div>
    </div>

    <div class="card" style="margin-top:16px">
      <h3>Signal Inbox</h3>
      <div class="content" id="inbox">
        <div class="skeleton" style="width:100%"></div>
      </div>
    </div>

    <footer>Theme: Terminal Pro · © KLine Analytics</footer>
  </div>

  <script>
    const chart = echarts.init(document.getElementById('chart'));
    const chart2 = echarts.init(document.getElementById('chart2'));
    const state = { symbol:'TEST', interval:'1d', interval2:'1h', candles:[], candles2:[], signals:[], overlayPrices:[], overlayCandles:[] };
    document.getElementById('symbol').value = state.symbol;
    document.getElementById('interval').value = state.interval;
    document.getElementById('interval2').value = state.interval2;

    // 使用增强的fetchWithRetry（由reliability.js提供）
    // 原始函数已被reliability.js中的enhancedFetchWithRetry替换
    async function fetchCandles(){
      const url = `/api/candles?symbol=${encodeURIComponent(state.symbol)}&interval=${state.interval}`;
      const res = await fetchWithRetry(url, {}, 3, 300); const arr = await res.json();
      state.candles = arr;
    }
    async function fetchCandles2(){
      const url = `/api/candles?symbol=${encodeURIComponent(state.symbol)}&interval=${state.interval2}`;
      const res = await fetchWithRetry(url, {}, 3, 300); const arr = await res.json();
      state.candles2 = arr;
    }
    async function fetchSignals(){
      const params = new URLSearchParams({ symbol: state.symbol });
      const opt = (id)=>{ const v=document.getElementById(id).value; return v?[[id,v]]:[] };
      ;['emaShort','emaLong','macdFast','macdSlow','macdSignal'].forEach(id=>{ const v=document.getElementById(id).value; if(v) params.append(id, v) });
      const res = await fetchWithRetry(`/api/signals?${params.toString()}`);
      state.signals = await res.json();
    }
    function renderChart(){
      const k = state.candles.map(c=>[new Date(c.timestamp).toISOString().slice(0,10), +c.open, +c.close, +c.low, +c.high]);
      const showSignals = document.getElementById('toggleSignals').checked;
      const sigPts = showSignals ? state.signals.map(s=>({ name: s.type, value:[new Date(s.timestamp).toISOString().slice(0,10), s.type==='BUY'?1:-1], itemStyle:{color:s.type==='BUY'?getComputedStyle(document.documentElement).getPropertyValue('--buy'):getComputedStyle(document.documentElement).getPropertyValue('--sell')}})) : [];
      const option = {
        animation: false,
        tooltip: { trigger: 'axis' },
        xAxis: { type: 'category', data: k.map(v=>v[0]) },
        yAxis: { scale:true },
        grid: { left: 40, right: 20, top: 20, bottom: 40 },
        series: [
          { type:'candlestick', name: state.symbol, data: k.map(v=>v.slice(1)) },
          ...(showSignals? [{ type:'scatter', name:'signals', data: sigPts, yAxisIndex:0 }]: [])
        ]
      };
      
      // 集成多周期联动
      if (window.multiTimeframeManager) {
        window.multiTimeframeManager.setCharts(chart, chart2);
      }
      const overlayOn = document.getElementById('overlayToggle').checked;
      if (overlayOn && state.overlayPrices.length){
        option.series.push({ type:'line', name:'overlay', data: k.map((v,i)=>[v[0], state.overlayPrices[i] ?? null]),
          smooth:true, showSymbol:false, lineStyle:{width:1, opacity:0.8} });
      }
      if (overlayOn && state.overlayCandles.length){
        // Build data: [catIndex, open, close, low, high]
        const ovData = [];
        for (let i=0;i<state.overlayCandles.length;i++){
          const oc = state.overlayCandles[i];
          if (!oc) continue;
          ovData.push([i, oc.open, oc.close, oc.low, oc.high]);
        }
        const upColor = getComputedStyle(document.documentElement).getPropertyValue('--buy').trim();
        const downColor = getComputedStyle(document.documentElement).getPropertyValue('--sell').trim();
        option.series.push({
          name:'overlay-candles', type:'custom', renderItem: function(params, api){
            const xIndex = api.value(0);
            const open = api.value(1), close = api.value(2), low = api.value(3), high = api.value(4);
            const x = api.coord([xIndex, open])[0];
            const openPoint = api.coord([xIndex, open]);
            const closePoint = api.coord([xIndex, close]);
            const lowPoint = api.coord([xIndex, low]);
            const highPoint = api.coord([xIndex, high]);
            const barWidth = 6; // pixels
            const style = api.style({
              stroke: 'rgba(255,255,255,0.0)',
              fill: (close>=open? upColor: downColor),
              opacity: 0.25
            });
            return {
              type: 'group',
              children: [
                { // wick
                  type: 'line', shape: { x1: x, y1: highPoint[1], x2: x, y2: lowPoint[1] }, style: { stroke: style.fill, lineWidth: 1, opacity: 0.5 }
                },
                { // body
                  type: 'rect', shape: {
                    x: x - barWidth/2,
                    y: Math.min(openPoint[1], closePoint[1]),
                    width: barWidth,
                    height: Math.max(1, Math.abs(closePoint[1] - openPoint[1]))
                  }, style: style
                }
              ]
            };
          },
          data: ovData,
          encode: { x: 0, y: [2,3,4] },
          silent: true
        });
      }
      chart.setOption(option);
      
      // 集成图表可视化增强
      if (window.chartVisualization) {
        window.chartVisualization.createSignalLegend(state.signals);
      }
    }
    function renderChart2(){
      const k = state.candles2.map(c=>[new Date(c.timestamp).toISOString().slice(0,10), +c.open, +c.close, +c.low, +c.high]);
      const option = { animation:false, tooltip:{trigger:'axis'}, xAxis:{type:'category', data:k.map(v=>v[0])}, yAxis:{scale:true}, grid:{ left:40, right:20, top:20, bottom:40 }, series:[{type:'candlestick', name:`${state.symbol} ${state.interval2}`, data:k.map(v=>v.slice(1))}] };
      chart2.setOption(option);
    }
    async function loadAll(){
      const inbox = document.getElementById('inbox'); inbox.innerHTML = '<div class="skeleton" style="width:100%"></div>';
      await fetchCandles(); await fetchSignals(); renderChart(); renderInbox();
      if (document.getElementById('linkTf').checked) { state.interval2 = pickLinkedTf(state.interval); document.getElementById('interval2').value = state.interval2; }
      await fetchCandles2(); renderChart2();
    }
    function pickLinkedTf(tf){
      const map = { '1d':'1h', '4h':'15m', '1h':'15m', '15m':'1m' };
      return map[tf] || '1h';
    }
    function renderInbox(){
      const box = document.getElementById('inbox');
      if (!state.signals.length){ box.innerHTML = '<div class="empty">No signals</div>'; return; }
      box.innerHTML = state.signals.map(s=>`<div class="badge" style="margin:6px 6px 0 0">${s.type} · ${s.strength?.toFixed? s.strength.toFixed(2):s.strength}</div>`).join('');
    }

    // localStorage persist/load
    const paramKeys = ['symbol','interval','emaShort','emaLong','macdFast','macdSlow','macdSignal'];
    function loadParams(){
      paramKeys.forEach(k=>{ const v=localStorage.getItem('kline_'+k); if (v) { const el=document.getElementById(k); if (el) el.value=v; }});
      state.symbol = document.getElementById('symbol').value || state.symbol;
      state.interval = document.getElementById('interval').value || state.interval;
    }
    function saveParams(){ paramKeys.forEach(k=>{ const el=document.getElementById(k); if (el && el.value) localStorage.setItem('kline_'+k, el.value); }); }

    document.getElementById('load').onclick = async ()=>{
      state.symbol = document.getElementById('symbol').value || 'TEST';
      state.interval = document.getElementById('interval').value || '1d';
      saveParams();
      await loadAll();
    };
    document.getElementById('load2').onclick = async ()=>{
      state.interval2 = document.getElementById('interval2').value || state.interval2;
      await fetchCandles2(); renderChart2();
    };
    document.getElementById('apply').onclick = async ()=>{ saveParams(); await loadAll(); };
    document.getElementById('runbt').onclick = async ()=>{
      const body = { strategyConfig: { name:'dsl', params: {
        emaShort: +document.getElementById('emaShort').value || 20,
        emaLong: +document.getElementById('emaLong').value || 50,
        macdFast: +document.getElementById('macdFast').value || 12,
        macdSlow: +document.getElementById('macdSlow').value || 26,
        macdSignal: +document.getElementById('macdSignal').value || 9
      } }, universe:[state.symbol], interval: state.interval, start: null, end: null, costModel:{bps:5}, slippageModel:{bps:5} };
      const res = await fetch('/api/strategy/backtest', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
      const json = await res.json();
      document.getElementById('btout').textContent = JSON.stringify(json.metrics || json, null, 2);
    };

    // Overlay from upload: map pixel y to price: price = refPrice + (refY - y) * pricePerPx
    document.getElementById('overlayBtn').onclick = async ()=>{
      const file = document.getElementById('overlayImg').files?.[0];
      if(!file){ alert('Choose an image'); return; }
      const fd = new FormData(); fd.append('file', file);
      const res = await fetch('/api/upload/analyze', { method:'POST', body: fd });
      const j = await res.json();
      const yinfo = j.axes?.y; const series = j.overlays?.series || [];
      if (!yinfo || typeof yinfo.pricePerPx !== 'number' || !yinfo.ref){ alert('No axis mapping from image'); return; }
      const refY = yinfo.ref.y; const refPrice = yinfo.ref.price; const ppx = yinfo.pricePerPx;
      // Align last N candles with overlay series idx 0..N-1 (0=most recent in our service)
      const N = Math.min(series.length, state.candles.length);
      const prices = new Array(state.candles.length).fill(null);
      const ocArr = new Array(state.candles.length).fill(null);
      for (let i=0;i<N;i++){
        const pt = series[i];
        if (typeof pt?.yClose === 'number'){
          const price = refPrice + (refY - pt.yClose) * ppx;
          prices[prices.length-1 - i] = +price.toFixed(6);
        }
        if (pt && [pt.yOpen,pt.yHigh,pt.yLow,pt.yClose].every(v=>typeof v==='number')){
          const map = y=> refPrice + (refY - y) * ppx;
          ocArr[ocArr.length-1 - i] = {
            open: +map(pt.yOpen).toFixed(6),
            high: +map(pt.yHigh).toFixed(6),
            low: +map(pt.yLow).toFixed(6),
            close: +map(pt.yClose).toFixed(6)
          };
        }
      }
      state.overlayPrices = prices;
      state.overlayCandles = ocArr;
      renderChart();
    };

    loadParams();
    loadAll();
    window.addEventListener('resize', ()=> { chart.resize(); chart2.resize(); });

    // Strategies panel
    async function loadStrats(){
      try {
        const res = await fetchWithRetry('/api/strategies/latest');
        const json = await res.json();
        const el = document.getElementById('strats');
        el.innerHTML = Object.entries(json).map(([k,v])=>`<div class="badge" style="margin:6px 6px 0 0">${k}: ${v}</div>`).join('') || '<div class="empty">No strategies</div>';
        // list items
        document.getElementById('stratList').textContent = JSON.stringify(json, null, 2);
      } catch(e){ document.getElementById('strats').innerHTML = '<div class="error">Failed to load strategies. Retry later.</div>'; }
    }
    loadStrats();

    // Strategy actions
    document.getElementById('btnPreviewStrategy').onclick = ()=>{
      try {
        const obj = JSON.parse(document.getElementById('strategyJson').value || '{}');
        document.getElementById('stratMsg').textContent = 'Valid JSON';
        document.getElementById('stratMsg').style.color = '#9AA4AE';
      } catch(e){
        document.getElementById('stratMsg').textContent = 'JSON Error: '+e.message;
        document.getElementById('stratMsg').style.color = '#ffb4b4';
      }
    };
    document.getElementById('btnRegisterStrategy').onclick = async ()=>{
      const id = document.getElementById('strategyId').value?.trim();
      const version = document.getElementById('strategyVersion').value?.trim();
      const json = document.getElementById('strategyJson').value || '{}';
      if (!id || !version) { document.getElementById('stratMsg').textContent = 'id/version required'; document.getElementById('stratMsg').style.color = '#ffb4b4'; return; }
      let dsl; try { dsl = JSON.parse(json); } catch(e){ document.getElementById('stratMsg').textContent = 'JSON Error: '+e.message; document.getElementById('stratMsg').style.color = '#ffb4b4'; return; }
      const body = { id, version, dsl };
      try {
        const res = await fetchWithRetry('/api/strategies', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) }, 2, 500);
        const out = await res.json();
        if (out.error) { document.getElementById('stratMsg').textContent = 'Register failed: '+(out.messages?.join?.('; ')||out.error); document.getElementById('stratMsg').style.color = '#ffb4b4'; }
        else { document.getElementById('stratMsg').textContent = 'Registered'; document.getElementById('stratMsg').style.color = '#9AA4AE'; loadStrats(); }
      } catch(e){ document.getElementById('stratMsg').textContent = 'Network Error: '+e.message; document.getElementById('stratMsg').style.color = '#ffb4b4'; }
    };
    document.getElementById('btnRollbackStrategy').onclick = async ()=>{
      // Simple client-side rollback: fetch list, re-register previous version as new version by bumping suffix
      try {
        const id = document.getElementById('strategyId').value?.trim(); if(!id) throw new Error('id required');
        const latestRes = await fetchWithRetry(`/api/strategies/${encodeURIComponent(id)}`);
        const versions = await latestRes.json();
        if (!Array.isArray(versions) || versions.length < 2) throw new Error('Not enough versions to rollback');
        const prev = versions[versions.length-2];
        const newVersion = (document.getElementById('strategyVersion').value?.trim()) || (prev.version+"-rollback");
        const body = { id, version: newVersion, dsl: prev.dsl };
        const res = await fetchWithRetry('/api/strategies', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) }, 2, 500);
        const out = await res.json();
        if (out.error) throw new Error(out.messages?.join?.('; ')||out.error);
        document.getElementById('stratMsg').textContent = `Rolled back to ${prev.version} -> ${newVersion}`;
        document.getElementById('stratMsg').style.color = '#9AA4AE';
        loadStrats();
      } catch(e){ document.getElementById('stratMsg').textContent = 'Rollback failed: '+e.message; document.getElementById('stratMsg').style.color = '#ffb4b4'; }
    };
  </script>
</body>
</html>


